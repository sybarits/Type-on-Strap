---
layout: post
title: Vector Processor
tags: [vector, processor, array]
---

벡터 프로세서(vector processor or array processor)는 벡터라고 불리는 다수의 데이터를 처리하는 명령어를 가진 CPU를 말한다. 컴퓨터에서 벡터란 1차원 배열의 데이터를 뜻한다. 벡터 프로세서와 반대되는 말로는 스칼라 프로세서가 있는데 한 개의 데이터를 처리하는 명령어를 가진 프로세서를 말한다. 대부분의 CPU는 스칼라 프로세서이다.

파이프라인(pipeline)이 복수의 명령어를 동시에 처리하는 것이라면 벡터 프로세싱은 복수의 데이터를 동시에 처리하는 것이다. 즉 스칼라 값인 1개의 데이터를 연산하는 것이 아니라 벡터로 구성된 여러 데이터를 1개의 명령어로 벡터 합, 차, 곱 등의 연산을 한다. 벡터 연산을소프트웨어가 아닌 하드웨어로 고속으로 처리한다.

벡터 프로세서는 1970년대 처음 나타났으며 1980년에서 1990년대 동안 슈퍼 컴퓨터의 기본적인 형태였다. 스칼라 프로세서, 특히 마이크로프로세서에서 성능을 높이기 위해 벡터 프로세서 기술을 도입한 CPU가 1990년대 초 나타났다. 오늘날 대부분의 cpu는 MMX, SSE, AltiVec 같이 다수의 데이터를 처리하는 베터 프로세싱을 위한 SIMD(Single Instruction Multiple Data) 명령어를 갖추고 있다. 벡터 프로세서 기술은 그래픽 가속기나 게임 콘솔에서도 찾아 볼 수 있다. 2000년 IBM, 도시바, 소니가 개발한 Cell Processor는 1개의 스칼라 프로세서와 8개의 벡터 프로세서로 구성되어 있으며 플레이스테이션 3에 사용되었다.

벡터 프로세싱을 위한 또 다른 CPU 디자인으로 다수의 명령어로 다수의 데이터를 처리하는 MIMD (Multiple Instruction Multiple Data)가 있지만 전문적인 용도로만 사용될 뿐 일반적인 용도로 쓰이지는 않았다.

## 역사
최초로 동작되는 벡터 프로세서는 1960년대 초, 웨스팅하우스의 솔로몬 프로젝트였다. 솔로몬의 목료는 많은 수의 단순한 수치 연산 코프로세서(ALU)를 1개의 마스터 CPU로 제어하는 방법을 사용해 수치 연산 성능을 극적으로 끌어올리는 것이었다. CPU는 사이클 당 하나의 공통 명령어를 모든 ALU로 보냈지만 데이터는 ALU 마다 각각 다르게 보내주었다. 이 방법은 솔로몬 머신에서 하나의 알고리즘을 배열 형태의 많은 데이터에 이용할 수 있도록 해준다. 1962년 웨스팅하우스는 솔로몬 프로젝트를 중단하였지만 벡터 프로세서의 개발에 대한 노력은 일리노이즈 대학의 일리악 IV에서 다시 시작되었다. 일리악은 256개의 ALU를 사용해 1 GFLOPS의 머신을 만들고자 하였으나 1972년 완성되었을 때는 64개의 ALU로 100 ~ 150 MFLOPS의 성능밖에 내지 못했다. 그렇지만 기본 개념은 충실해서 유체역학과 같은 데이터 중심의 애플리케이션에서는 세계에서 가장 빠른 머신이었다. 일리악의 각 데이터 요소마다 별도의 ALU를 사용한 방법은 이후 벡터 프로세서 설계에서도 일반적인 것은 아니었으며 대규모 병렬 컴퓨팅 범주로 구분되기도 한다.

초창기 벡터 프로세서 시스템 중 유명한 것은 CDC(Control Data Corporation)의 STAR-100과 텍사스 인스트루먼츠의 ASC(Advanced Scientific Computer)였다. ASC의 ALU는 1개의 파이프를 가진 파이프라인 아키텍처를 사용해 스칼라와 벡터 연산을 모두 처리할 수 있었으며 최대 성능은 길이가 긴 벡터를 처리할 경우 약 20MFLOPS에 달했다. 확장 ALU 구성에서는 2개나 4개로 파이프를 확장해 2배나 4배의 성능을 얻을 수 있었다. 메모리 대역폭은 확장 모드를 사용하는데 충분했다. STAR는 CDC 7600 같은 CDC의 슈퍼 컴퓨터보다느 ㄴ느릴지는 몰라도 데이터 관련 작업에서는 크기도 작고 가격도 낮았다. 하지만 STAR는 벡터 명령어를 디코딩하고 프로세스의 실행을 준비하는데 시간이 많이 걸렸다. 그래서 실제 성능을 발휘하려면 매우 일정한 데이터 집합이 필요했다.

벡터 기술은 크레이-1에서 처음으로 완성되었다. 크레이는 STAR나 ASC 같이 데이터를 메모리에 남겨두지 않고 8개의 벡터 레지스터를 사용했다. 벡터 레지스터는 64비트 워드 64개로 이루어져 있다. 벡터 명령어는 레지스터 사이에서 실행되었는데 메인 메모리에서 가져오는 방법보다 훨씬 빨랐다. 크레이는 벡터 명령어를 실행하는데 다수의 ALU를 사용하는 대신 파이프라인 병령화를 사용했다. 이 방법은 명령어에 따라 파이프라인을 나누어 놓은 것으로 예를 들어 덧셈/뺄셈은 곱셈과는 다른 파이프라인에서 실행된다. 이런 기술을 벡터 체이닝이라 부른다. 크레이-1의 일반적인 성능은 80 MFLOPS 저옫였으나 3개의 체인으로 실행할 경우 최대 성능은 240 MFLOPS를 기록했다.

벡터 프로세싱 기술은 최근 거의 모든 CPU에서 SIMD라는 명칭으로 추가되었다. 베터 유닛은 프로그램으로부터 처리할 데이터를 받아 메인 스칼라 CPU와 동시에 작동한다.

## 특징




출처: https://ko.wikipedia.org/wiki/%EB%B2%A1%ED%84%B0_%ED%94%84%EB%A1%9C%EC%84%B8%EC%84%9C  
https://article2.tistory.com/697
