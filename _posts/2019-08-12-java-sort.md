---
layout: post
title: Java Sort Algorithm
tags: [sort, comparator, java ]
excerpt_separator: <!--more-->
---

자바를 이용해 정렬 알고리즘에 대해 알아보자.  

## Bubble Sort
* 버블 정렬
* 서로 인접한 두 원소를 검사하여 정렬한다.
* 아래 코드는 오름차순 정렬이다.

```java
void swap (int[] array, int fromIdx, int targetIdx) {
  int temp = array[targetIdx]; // 목적지 원소를 임시 저장
  array[targetIdx] = array[fromIdx];
  array[fromIdx] = temp;
}

void bubbleSort(int[] arr){
  for (int i = arr.length - 1; i > 0; i --)// main loop, i 는 (배열의 길이 - 1) 에서 1까지 1씩 감소
    for (int j =0; j < i ; j++)	// j 는 0부터 i 까지 1씩 증가하며 반복
      if (arr[j] > arr[j+1]) swap(arr, j, j+1); // index 가 작은 원소가 클경우 교환
}
```

## Selection Sort
* 선택 정렬
* 버블 정렬과 마찬가지로 입력 된 배열이외의 저장공간을 필요로 하지 않는다.
* 버블 정렬보다는 빠르다.
* 한번 배열을 돌때마다 가장 큰(혹은 작은) 값의 인덱스를 가지고 위치를 선정하여 바꾼다.

```java
void selectionSort(int[] arr){
  for (int i = arr.length - 1; i > 0; i --) {
    int maxIndex = 0 ; // 배열 원소중 max 값의 index를 저장할 변수
    for (int j = 1; j <= i ; j++)
      if (arr[j] > arr[maxIndex]) maxIndex = j;
    if (i != maxIndex) //바꾸어야할 index가 자기 자신이 아니면 교환
      swap(arr, maxIndex, i);
  }
}
```

## Insertion Sort
* 삽입 정렬
* 손안의 카드를 정렬하는 것과 유사한 방법
* 두번째 요소부터 비교를 시작한다. 하나의 요소의 앞부분(혹은 뒷부분)에 있는 요소들과 비교하여 적절한 위치에 넣는다.
* 버블 정렬, 선택 정렬 보다는 빠르다

```java
void insertionSort(int[] arr){
  for(int i = 1; i < arr.length; i++) { // i가 0이 아니라 1부터 시작
    int ai = arr[i]; // 정렬된 앞 배열에 삽입될 원소
    int j;
    for (j = i; j > 0 && arr[j-1] > ai; j--) // 정렬된 배열에서 ai 보다 큰 값이 나올 때까지 j 감소
      arr[j] = arr[j - 1]; // 원소가 한 칸씩 우측으로 이동
    arr[j] = ai;  // 마지막으로 나온 j에 ai 를 삽입
  }
}
```

## Shell Sort
* 셸 정렬
* 삽입 정렬을 보완한 알고리즘으로 Donald L. Shell 이라는 사람이 제안
* 어느 정도 정렬 된 배열에 대해서 삽입 정렬이 대단히 빠른 것에 착안
* 삽입 정렬에 비해 빠르고, 구현도 비교적 간단하다.
* 삽입 정렬과는 달리 셸 정렬은 전체 리스트를 한번에 정렬하지 않는다.
* 정렬해야 할 리스트의 k번째 요소를 추출해서 부분 리스트를 만든다. k는 gap(간격)이라 부른다.
* 간격의 초기값: (정렬 할 요소의 수)/2
* loop가 돌때 마다 k를 절반으로 줄인다.
* 간격을 절반으로 줄일 때 짝수가 나오면 +1을 해서 홀수로 만든다.
* 간격이 1이 될 때 까지 반복한다.

```java
void insertionSort(int[] arr, int startIndex, int gap) {
  for(int i = startIndex + gap; i < arr.length; i+=gap) { 
    // 삽입정렬과 다르게 i가 startIndex + gap에서 시작하고 증분이 1이 아니고, gap이 된다.
    int ai = arr[i];
    int j;
    for (j = i; j > startIndex && arr[j-1] > ai; j--) // j > 0 대신 j > startIndex 사용
      arr[j] = arr[j - 1];
    while (j > gap && arr[j-gap] > ai) { // arr[j-1] 대신에 arr[j-gap] 을 사용 
      arr[j] = arr[j-gap]; // arr[j-1] 대신에 arr[j-gap] 을 사용
      j -= gap;
    }
    arr[j] = ai;
  }
}

// 쉘 정렬
void shellSort(int[] arr){
  for(int gap = arr.length/2; gap > 0; gap /= 2) { // main loop, gap 을 2씩 나눔.. 4, 2, 1
    if (gqp%2 == 0)gap++; //gap이 짝수이면 1을 더해서 홀수로 만듬
    for (int startIndex = 0; startIndex < gap; startIndex++) 
      insertionSort(arr, startIndex, gap);
  }
}
```

## Merge Sort
* 병합 정렬
* John von Neumann(존 폰 노이만)이라는 사람이 제안한 방법
* 이 정렬은 안정 정렬에 속하며, 분할 정복 알고리즘의 하나이다.

```java
void mergeSort(int[] arr, int startIndex, int last) { // 오버로드로 선언 매개변수 개수만 다릅니다.
  // 선조건 : 0 < startIndex < last <= arr.length
  // 후조건 : arr[startIndex...last-1]은 오름차순이다.
  if(last - startIndex < 2) return;
  int middleIdex = (last + startIndex) / 2; // 배열의 중간 index

  mergeSort(arr, startIndex, middleIdex); // [startIndex, middleIdex) 반열린구간 
  mergeSort(arr, middleIdex, last); // [middleIdex, last) 반열린구간 
  merge(arr, startIndex, middleIdex, last);
}

void merge(int[] arr, int startIndex, int middleIdex, int last) {
  // 선조건 : arr[startIndex...middleIdex-1] 과 arr[middleIdex...last-1] 은 오름차순이다.
  // 후조건 : arr[startIndex...last-1] 은 오름차순이다.
  if(arr[middleIdex -1] <= arr[middleIdex]) return;
  int i = startIndex, j = middleIdex, k = 0; // k는 합병된 원소의 개수
  int[] tempArr = new int[last - startIndex];
  while (i < middleIdex && j < last) // 여기서 합병되면서 정렬이 됨
    if(arr[i] < arr[j]) tempArr[k++] = arr[i++]; 
    else tempArr[k++] = arr[j++]; 
  if(i < middleIdex) System.arraycopy(arr, i, arr, startIndex + k, middleIdex - i); 
  // shift arr[i...midddleIndex - 1] 
  System.arraycopy(tempArr, 0, arr, startIndex, k); // copy tempArray[0...k-1] to arr[p...p+k-1]
}

```

좀 더 남았다...

출처: https://gmlwjd9405.github.io  
https://blog.khphub.com/entry/Sort-Algorithm%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-JAVA
