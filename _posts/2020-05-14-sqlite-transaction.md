---
layout: post
title: SQLite Transaction
tags: [sqlite, transaction]
---

## 트랜잭션
쪼개질 수 없는 업무처리의 단위 – 원자성(Atomicity) CRUD

* DB에서 트랜잭션을 처리하기 위해 다음과 같은 기술을 제공한다.
1. 롤백(Rollback): 부분 작업이 실패하면 트랜잭션 실행 전으로 되돌린다.
2. 커밋(Commit): 모든 부분작업이 정상적으로 완료하면 이 변경사항을 한꺼번에 DB에 반영한다.

* ACID(Atomicity, Consistency, Isolation, Durability)는 데이터베이스 트랜잭션이 안전하게 수행된다는 것을 보장하기 위한 성질을 가리키는 약어이다.
1. 원자성(Atomicity): 트랜잭션에 속한 작업들이 모두 수행되었는지 아니면 모두 실행이 안되었는지를 보장하는 능력이다. 즉, 중간 단계까지 실행되고 실패하는 일은 없도록 하는 것이다.
2. 일관성(Consistency): 트랜잭션이 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 유지하는 것을 의미한다.
3. 고립성(Isolation): 트랜잭션 수행 시 다른 트랜잭션의 연산 작업이 끼어들지 못하도록 보장하는 것을 의미한다.
4. 지속성(Durability): 성공적으로 수행된 트랜잭션은 영원히 반영되어야 함을 의미한다.

## 웹 어플리케이션 환경에서 트랜잭션
웹 어플리케이션 환경에서 계좌이체를 할 경우 계좌이체 버튼을 누르고 요청에 대한 응답을 보여주는 것까지 하나의 트랜잭션이라고 볼 수 있다. 이를 위해 여러 프레임워크에서 트랜잭션 처리에 대한 기능을 제공한다.
	Django 1.6 버전에서 ATOMIC_REQUEST 라는 설정 기능을 추가했다. setting.js에서 ATOMIC_REQUEST = True 로 설정하면 요청부터 응답까지 프레임워크가 하나의 트랜잭션으로 처리한다.
	스프링 프레임워크 역시 선언적 트랜잭션 관리와 프로그래밍 방식 트랜잭션 관리를 제공한다. 이중 가장 간단한 방법으로 어노테이션 기반의 방법을 사용할 수 있다. 트랜잭션을 적용하고 싶은 메소드 위에 @Transactional 을 붙이고, context.xml 에 해당 메소드에 트랜잭션을 적용하기 위한 설정을 추가해준다.
 이 외에 프레임워크들이 제공하는 트랜잭션 기능이 있고, 프레임워크가 올라가는 환경에 따라 트랜잭션 기능을 적용하는데 조금씩 다른 부분들이 있다. 각 프레임워크에서 제공하는 트랜잭션 기능 구현 상세는 추후에 다룬다.

## Node.js에서 트랜잭션
Oracle, SQL-Server, MySQL, PostgreSQL과 같이 잘 알려진 DBMS들은 Database Driver 단에서 트랜잭션을 제공한다. Node.js를 이용한 어플리케이션에서 트랜잭션을 구현하기 위해서는 트랜잭션 기능을 지원하는 database driver를 사용하여 구현하면 된다. 따라서 어떤 DBMS를 사용하는지에 따라 트랜잭션 기능을 이용하기 위한 방법은 조금식 다를 것이다. Sqlite의 경우 DB 자체가 트랜잭션의 기본적인 기능을 지원하며, Node.js에서 이 기능을 활용하여 어플리케이션의 트랜잭션 처리가 가능하다.
아래와 같이 쿼리 문을 실행할 때 BEGIN TRANSACTION; 구문을 먼저 실행한 후 COMMIT; 구문을 실행하여 트랜잭션을 완료한다.

```
BEGIN TRANSACTION;
UPDATE accounts
  SET balance = balance - 1000
 WHERE account_no = 100;
UPDATE accounts
  SET balance = balance + 1000
 WHERE account_no = 200;
INSERT INTO account_changes(account_no,flag,amount,changed_at)
VALUES(100,'-',1000,datetime('now'));
INSERT INTO account_changes(account_no,flag,amount,changed_at)
VALUES(200,'+',1000,datetime('now'));
COMMIT;
```

혹은 COMMIT; 대신 ROLLBACK; 구문을 사용하여 BEGIN TRANSACTION; 구문 이후 실행한 구문을 되돌려 트랜잭션을 완료할 수도 있다.

## SQLite DB Lock
SQLite의 가장 큰 특징이자 문제점은 작업을 직접 파일에 한다는데 있다. create, update, delete 실행 시 파일에 lock을 잡기 때문에 다른 스레드에서 작업이 불가능하다. Select를 할 때는 shared lock을 잡아 여러 스레드에서 읽기가 가능하다. 부하가 적은 환경에서는 이런 특징이 크게 문제되지 않지만, 부하가 커지면 커질수록 문제가 된다. 10000개의 insert 명령을 실행하는 node.js 프로그램 두개를 동시에 실행시켜 하나의 DB에 쓰기를 하는 테스트 결과 하나의 프로그램이 비정상 동작하는 것을 확인하였다.
	MySQL과 같은 DBMS는 여러 명의 동시 사용자에 대응하도록 설계되었지만, 앞서 언급한 특징들로 인해 SQLite는 데스크톱 또는 모바일 앱과 같이 동시 사용자가 한 명인 애플리케이션에 가장 적합하다. 또한 MySQL은 클러스터 및 수평 확장 솔루션을 제공할 수 있지만 SQLite는 할 수 없다.

## SQLite 구성 방법
	여러 스레드에서 읽기만 하는 작업이 많은 경우 읽기 전용 DB와 쓰기전용 DB를 만드는 방법을 이용해 읽기의 성능을 하락하지 않도록 할 수 있다. 쓰기 요청 처리의 경우 단일 쓰레드에서 처리하도록 모든 요청을 한곳에 모으고 큐를 두도록 한다. 두 DB간의 싱크는 시간을 두고 주기적으로 천천히 맞추도록 한다.
	읽기/쓰기 DB를 별도로 구성해도 동시다발적인 쓰기 요청이 많을 경우 성능에 문제가 있을 수 있다. SQLite의 경우 인메모리 DB기능을 제공한다. 이 기능을 캐시처럼 사용할 수 있다. 초반 어플리케이션 실행 시 database에 있는 내용(파일에 저장되어있는 sqlite DB)을 읽어와 캐시에 넣어두고 어플리케이션은 이 캐시만 사용하도록 한다. 캐시는 주기적으로 database에 저장을 하여 안전성을 확보한다. 이 방법 역시 sqlite DB를 중복으로 구축하는 방법이지만, 읽기와 쓰기 요청을 나누지 않고 인메모리 DB에 모두 모은다. 파일을 사용하는 DB는 저장과 복원을 위한 역할을 한다. 이 방법의 단점은 메모리 자원이 비교적 많이 필요하며, 메모리에 우선적으로 저장하는 만큼 데이터 손실의 위험성이 어느정도 있다.
	캐시를 DB와 동일하게 가져갈 경우 database의 용량이 커질 수록 메모리 사용이 커진다. 캐싱 전략을 바꿔보도록 한다. 읽기(select)의 경우 일정 시간 동안 캐싱하여 메모리 소모를 줄인다. 쓰기(create, update, delete)의 경우 일정 시간 동안 들어오는 요청을 모아두었다가 한 번에 파일 DB로 요청을 보낸다. 요청이 완료된 이후 캐싱 정보를 확인하여   이때 캐시는 일종의 버퍼 역할을 한다. 여러 클라이언트에서 한 번에 DB에 접근하는 것을 막을 수 있는 효과를 가질 수 있지만, 이 방법 역시 장애 시 데이터의 손실을 가져올 수 있다.
	 
	위와 같은 현상과 해결 방법은 SQLite 에만 해당되는 것은 아니다. 다만 sqlite는 database 하나를 파일 하나로 관리하여 파일에 직접 읽기/쓰기를 진행하기 때문에 한계상황이 비교적 빨리 온다. SQLite는 기본적으로 단일 어플리케이션에 쓰이는 용도로 만들어 졌기 때문에 한계점이 명확하다. 여러 클라이언트들이 접근해야 하는 부하가 걸리는 시나리오에서는 지금까지 생각해 본 SQLite의 구성 방법을 이용해본다. 성능 이슈가 해결할 수 없는 상황에 오는 상황이거나, 클러스터 및 수평확장이 필요한 시나리오의 경우 다른 DBMS 사용에 대해 고려해보아야 한다. 다른 DBMS가 사용되는 경우 캐시 솔루션으로 redis를 많이 사용한다.

